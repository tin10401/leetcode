class UnionFind {
public:
    vector<int> root, infectedRank, normalRank;
    unordered_set<int> infected;
    int n;

    UnionFind(int n, vector<int>& initial) {
        infected = {initial.begin(), initial.end()};
        this->n = n;
        root.resize(n), infectedRank.resize(n, 0), normalRank.resize(n, 1);
        for (int i = 0; i < n; ++i) {
            root[i] = i;
        }
        for (auto& it : infected) {
            infectedRank[it]++;
        }
    }

    int find(int x) {
        if (root[x] == x) return x;
        return root[x] = find(root[x]);
    }

    void merge(int x, int y) {
        int u = find(x), v = find(y);
        if (u != v) {
            if (infected.count(v) || (!infected.count(u) && normalRank[v] > normalRank[u])) swap(u, v);
            root[v] = u;
            normalRank[u] += normalRank[v];
            infectedRank[u] += infectedRank[v];
        }
    }

    int queries() {
        int best = -1, maxi = -1;
        for (int i = 0; i < n; i++) {
            if (find(i) == i) {
                int count = infectedRank[i];
                int totalNode = normalRank[i];
                if (count == 1 && totalNode > maxi) {
                    maxi = totalNode;
                    best = i;
                }
            }
        }
        return best;
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        UnionFind uf(n, initial);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 1) {
                    uf.merge(i, j);
                }
            }
        }
        int res = uf.queries();
        if (res == -1) return *min_element(initial.begin(), initial.end());
        return res;
    }
};
