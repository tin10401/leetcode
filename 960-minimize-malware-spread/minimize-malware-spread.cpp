class UnionFind
{
    public:
    vector<int> root, infectedRank, normalRank;
    unordered_set<int> infected;
    int n;
    UnionFind(int n, vector<int>& initial)
    {
        infected = {begin(initial), end(initial)};
        this->n = n;
        root.resize(n, -1), infectedRank.resize(n, 0), normalRank.resize(n, 1);
        for(auto& it : infected)
        {
            infectedRank[it]++;
        }
    }

    int find(int x)
    {
        if(root[x] == -1) return x;
        return root[x] = find(root[x]);
    }

    void merge(int x, int y)
    {
        int u = find(x), v = find(y);
        if(u != v)
        {
            if(infected.count(v) || (!infected.count(u) && normalRank[v] > normalRank[u])) swap(u, v);
            root[v] = u;
            normalRank[u] += normalRank[v];
            infectedRank[u] += infectedRank[v];
        }
    }

    int queries()
    {
        int best = -1, maxi = -1;
        for(int i = 0; i < n; i++)
        {
            if(root[i] == -1)
            {
                int count = infectedRank[i];
                int totalNode = normalRank[i];
                if(count == 1 && totalNode > maxi)
                {
                    maxi = totalNode;
                    best = i;
                }
            }
        }
        return best;
    }


};
class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        UnionFind root(n, initial);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(graph[i][j]) root.merge(i, j);
            }
        }
        int res = root.queries();
        if(res == -1) return *min_element(begin(initial), end(initial));
        return res;
    }
};