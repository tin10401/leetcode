class UnionFind
{
    public:
    vector<int> infectedRank, normalRank, root;
    int n;
    unordered_set<int> infected;
    UnionFind(int n, vector<int>& init)
    {
        this->n = n;
        root.resize(n, -1), infectedRank.resize(n), normalRank.resize(n, 1);
        infected = {begin(init), end(init)};
        for(auto& i : infected) infectedRank[i]++;
    }

    int find(int x)
    {
        if(root[x] == -1) return x;
        return root[x] = find(root[x]);
    }

    void merge(int x, int y)
    {
        int u = find(x), v = find(y);
        if(u != v)
        {
            if(!infected.count(u) && (infected.count(v) || normalRank[v] > normalRank[u])) swap(u, v);
            normalRank[u] += normalRank[v];
            infectedRank[u] += infectedRank[v];
            root[v] = u;
        }
    }

    int queries()
    {
        int res = -1, maxi = -1;
        for(int i = 0; i < n; i++)
        {
            if(root[i] == -1 && infectedRank[i] == 1 && normalRank[i] > maxi)
            {
                maxi = normalRank[i];
                res = i;
            }
        }
        return res;
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        int n = graph.size();
        UnionFind root(n, initial);
        for(int i = 0; i < n; i++)
        {
            for(int j = 0; j < n; j++)
            {
                if(graph[i][j]) root.merge(i, j);
            }
        }

        int res = root.queries();
        if(res == -1) return *min_element(begin(initial), end(initial));
        return res;
    }
};